// Generated by ChatGPT
#ifndef UTILS_CSVPARSABLE_H
#define UTILS_CSVPARSABLE_H

#include <iostream>
#include <tuple>
#include <string_view>
#include <sstream>
#include <vector>
#include <type_traits>

namespace utils {
// -------------------- CSVField Protocol --------------------
template<typename T>
struct CSVField {
  static void parse(std::string_view token, T& field) {
    static_assert(false, "CSVField<T>::parse must be specialized for type T");
  }

  static void write(std::ostream& os, const T& value) {
    static_assert(false, "CSVField<T>::parse must be specialized for type T");
  }
};

// Specializations for common types
template<>
struct CSVField<int> {
  static void parse(std::string_view token, int& field) {
    field = std::stoi(std::string(token));
  }

  static void write(std::ostream& os, const int& value) {
    os << value;
  }
};

template<>
struct CSVField<double> {
  static void parse(std::string_view token, double& field) {
    field = std::stod(std::string(token));
  }

  static void write(std::ostream& os, const double& value) {
    os << value;
  }
};

template<>
struct CSVField<std::string> {
  static void parse(std::string_view token, std::string& field) {
    field = std::string(token);
  }

  static void write(std::ostream& os, const std::string& value) {
    os << value;
  }
};

template<>
struct CSVField<std::string_view> {
  static void parse(std::string_view token, std::string_view& field) {
    field = token;
  }

  static void write(std::ostream& os, const std::string_view& value) {
    os << value;
  }
};

// -------------------- CSV Helper --------------------
inline std::vector<std::string_view> split_csv(std::string_view line) {
  std::vector<std::string_view> result;
  size_t start = 0;
  size_t end = 0;

  while ((end = line.find(',', start)) != std::string_view::npos) {
    result.emplace_back(line.substr(start, end - start));
    start = end + 1;
  }
  result.emplace_back(line.substr(start)); // Add the last token
  return result;
}

// -------------------- Tuple Iteration --------------------
template<typename Tuple, typename Func, std::size_t... Is>
void for_each(Tuple&& t, Func&& f, std::index_sequence<Is...>) {
  (f(std::get<Is>(t), Is), ...); // Fold expression
}

template<typename Tuple, typename Func>
void for_each(Tuple&& t, Func&& f) {
  constexpr auto size = std::tuple_size<std::decay_t<Tuple>>::value;
  for_each(std::forward<Tuple>(t),
           std::forward<Func>(f),
           std::make_index_sequence<size>{});
}

// -------------------- Base Class --------------------
template<typename Derived>
struct CSVParsable {
  void parse(std::string_view line) {
    auto tokens = split_csv(line);
    if (tokens.size() != Derived::num_fields) {
      throw std::runtime_error("CSV field count mismatch");
    }

    auto fields = static_cast<Derived*>(this)->tie_fields();
    for_each(fields, [&](auto& field, std::size_t i) {
      using FieldType = std::decay_t<decltype(field)>;
      CSVField<FieldType>::parse(tokens[i], field); // Use CSVField<T>::parse
    });
  }

  void write(std::ostream& os) const {
    auto fields = static_cast<const Derived*>(this)->tie_fields();
    bool first = true;
    for_each(fields, [&](const auto& field, std::size_t) {
      if (!first) {
        os << ",";
      }
      first = false;
      using FieldType = std::decay_t<decltype(field)>;
      CSVField<FieldType>::write(os, field); // Use CSVField<T>::write
    });
  }
};

// -------------------- Macro for Field Registration --------------------
#define CSV_DATA_FIELD(...) \
  auto tie_fields() { return std::tie(__VA_ARGS__); } \
  auto tie_fields() const { return std::tie(__VA_ARGS__); } \
  static constexpr size_t num_fields = \
    std::tuple_size<decltype(std::tie(__VA_ARGS__))>::value;
    
} // end namespace utils

#endif // UTILS_CSVPARSABLE_H