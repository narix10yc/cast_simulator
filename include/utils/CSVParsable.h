// Generated by ChatGPT
#ifndef UTILS_CSVPARSABLE_H
#define UTILS_CSVPARSABLE_H

#include <array>
#include <iostream>
#include <sstream>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <vector>
#include <cassert>

namespace utils {
// -------------------- CSVField Protocol --------------------
template <typename T> struct CSVField {
  static void parse(std::string_view token, T& field) {
    static_assert(false, "CSVField<T>::parse must be specialized for type T");
  }

  static void write(std::ostream& os, const T& value) {
    static_assert(false, "CSVField<T>::parse must be specialized for type T");
  }
};

// Specializations for common types
template <> struct CSVField<int> {
  static void parse(std::string_view token, int& field) {
    field = std::stoi(std::string(token));
  }

  static void write(std::ostream& os, const int& value) { os << value; }
};

template <> struct CSVField<double> {
  static void parse(std::string_view token, double& field) {
    field = std::stod(std::string(token));
  }

  static void write(std::ostream& os, const double& value) { os << value; }
};

template <> struct CSVField<std::string> {
  static void parse(std::string_view token, std::string& field) {
    field = std::string(token);
  }

  static void write(std::ostream& os, const std::string& value) { os << value; }
};

template <> struct CSVField<std::string_view> {
  static void parse(std::string_view token, std::string_view& field) {
    field = token;
  }

  static void write(std::ostream& os, const std::string_view& value) {
    os << value;
  }
};

// -------------------- CSV Helper --------------------
inline std::vector<std::string_view> split_csv(std::string_view line) {
  std::vector<std::string_view> result;
  size_t start = 0;
  size_t end = 0;

  while ((end = line.find(',', start)) != std::string_view::npos) {
    result.emplace_back(line.substr(start, end - start));
    start = end + 1;
  }
  result.emplace_back(line.substr(start)); // Add the last token
  return result;
}

// -------------------- Tuple Iteration --------------------
template <typename Tuple, typename Func, std::size_t... Is>
void for_each(Tuple&& t, Func&& f, std::index_sequence<Is...>) {
  (f(std::get<Is>(t), Is), ...); // Fold expression
}

template <typename Tuple, typename Func> void for_each(Tuple&& t, Func&& f) {
  constexpr auto size = std::tuple_size<std::decay_t<Tuple>>::value;
  for_each(std::forward<Tuple>(t),
           std::forward<Func>(f),
           std::make_index_sequence<size>{});
}

// -------------------- Base Class --------------------
template <typename Derived> struct CSVParsable {
  void parse(std::string_view line) {
    auto tokens = split_csv(line);
    assert(tokens.size() == Derived::num_fields);

    auto fields = static_cast<Derived*>(this)->tie_fields();
    for_each(fields, [&](auto& field, std::size_t i) {
      using FieldType = std::decay_t<decltype(field)>;
      CSVField<FieldType>::parse(tokens[i], field); // Use CSVField<T>::parse
    });
  }

  void write(std::ostream& os) const {
    auto fields = static_cast<const Derived*>(this)->tie_fields();
    bool first = true;
    for_each(fields, [&](const auto& field, std::size_t) {
      if (!first) {
        os << ",";
      }
      first = false;
      using FieldType = std::decay_t<decltype(field)>;
      CSVField<FieldType>::write(os, field); // Use CSVField<T>::write
    });
  }
};

// -------------------- Macro for Field Registration --------------------

// Trim the leading and trailing spaces from a string_view
consteval std::string_view trim(std::string_view str) {
  std::size_t start = 0;
  std::size_t end = str.size();

  while (start < end && str[start] == ' ')
    ++start;
  while (end > start && str[end - 1] == ' ')
    --end;

  return str.substr(start, end - start);
}

// Main consteval function to clean CSV title
template <std::size_t N>
consteval auto clean_csv_title(const char (&input)[N]) {
  std::array<char, N> out{};
  std::size_t out_i = 0;

  std::size_t token_start = 0;
  for (std::size_t i = 0; i <= N; ++i) {
    if (input[i] == ',' || input[i] == '\0') {
      auto token = trim(std::string_view(&input[token_start], i - token_start));
      for (char c : token)
        out[out_i++] = c;

      // Add comma if not at the end
      if (input[i] == ',') {
        out[out_i++] = ',';
        token_start = i + 1;
      } else
        break;
    }
  }

  out[out_i] = '\0';
  return out;
}

#define CSV_STRINGIFY(...) #__VA_ARGS__

#define CSV_DATA_FIELD(...)                                                    \
  auto tie_fields() { return std::tie(__VA_ARGS__); }                          \
  auto tie_fields() const { return std::tie(__VA_ARGS__); }                    \
  static constexpr size_t num_fields =                                         \
      std::tuple_size<decltype(std::tie(__VA_ARGS__))>::value;                 \
  static constexpr auto CSV_TITLE_STORAGE =                                    \
      utils::clean_csv_title(CSV_STRINGIFY(__VA_ARGS__));                      \
  static constexpr std::string_view CSV_TITLE{CSV_TITLE_STORAGE.data()};

} // end namespace utils

#endif // UTILS_CSVPARSABLE_H